---
title: Parameterized report w/o API
output: 
  html_document:
    code_folding: hide
params:
  forecasters:
    label: "Forecasters:"
    choices: [COVIDhub-ensemble, COVIDhub-baseline, CMU-TimeSeries, Karlen-pypm,CU-select, Google_Harvard-CPF, MIT-Cassandra, COVIDhub-trained_ensemble]
    value: [COVIDhub-ensemble, COVIDhub-baseline, CMU-TimeSeries, Karlen-pypm, CU-select, MIT-Cassandra, COVIDhub-trained_ensemble]
    input: select
    multiple: TRUE
  colorblind_palette: TRUE
  weeks: 
    label: "Weeks"
    value: [1,2,3,4]
    input: select
    choices: [1,2,3,4]
    multiple: True
  printcode: TRUE
editor_options: 
  chunk_output_type: inline
---

**Package installation**

```{r common-stuff, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(autodep = TRUE, fig.align = "center", message = FALSE, warning = FALSE, echo=params$printcode)
source("revised_larry.R")
library(covidcast)
library(evalcast)
library(modeltools)
#library(quantgen)
library(tidyverse)
library(zookeeper)
library(namespace)
#library(devtools)
#library(usethis)
library(assertthat)  # needed for this particular forecaster
library(sf)
library(Cairo)
library(tidyverse)
library(viridis)
library(ggplot2)
library(plotly)
library(here)
```
**Everything above might be unnecessary**


```{r}
##This is for the cases:
# url2 <- "https://forecast-eval.s3.us-east-2.amazonaws.com/score_cards_nation_cases.rds"
# download.file(url2, "eval_cases.RDS") # download to disk
# scores <- readRDS(paste0(here(), "/eval_cases.RDS"))
#scores_total <- rbind(scores,scores2)

url1 <- "https://forecast-eval.s3.us-east-2.amazonaws.com/score_cards_state_deaths.rds"
download.file(url1, "eval_deaths.RDS") # download to disk
scores2 <- readRDS(paste0(here(), "/eval_deaths.RDS"))
scores3 <- subset(scores2,  forecaster %in% params$forecasters)
```

```{r get-forecast-dates}
our_pred_dates <- 
  scores3 %>%
  filter(forecaster == "CMU-TimeSeries") 

our_pred_dates <- unique(our_pred_dates$forecast_date) 
n_dates <- length(our_pred_dates)

# n_dates - 4 is often the most recent date with ground truth for 4 weeks ahead
# dates spaced out 2 weeks ahead to see different behaviors
forecast_dates <- our_pred_dates[n_dates- 2 *5:2]
```


```{r}
scores3$forecast_date <- 
  if_else(scores3$forecaster %in% c("Karlen-pypm", "CU-select"), scores3$forecast_date + 1, scores3$forecast_date)

scores3 <- subset(scores3, forecast_date %in% forecast_dates)
results <- intersect_averagers(scores3, c("forecaster"), c("forecast_date", "geo_value"))

results %>%
  group_by(forecast_date) %>%
  summarise(n_distinct(geo_value))
```

<!-- ```{r evaluate-predictions, messages=F, warning=F} -->
<!-- # for county prediction, set geo_type = "county" -->
<!-- results <- evaluate_covid_predictions(all_predictions, -->
<!--                                       backfill_buffer = 0, -->
<!--                                       geo_type = "state") %>% -->
<!--   intersect_averagers(c("forecaster"), c("forecast_date", "geo_value")) -->

<!-- all_predictions %>% -->
<!--   group_by(forecast_date) %>% -->
<!--   summarise(n_distinct(geo_value)) -->
<!-- ``` -->

## Overall AE, WIS, Coverage 80
NOTE: Results are based on the following numbers of common locations

```{r overall}
weeks.label = c("1 week ahead", "2 weeks ahead", "3 weeks ahead", "4 weeks ahead")
names(weeks.label) = c(1, 2, 3, 4)

subtitle = sprintf("Forecasts made over %s to %s",
                   format(min(forecast_dates), "%B %d, %Y"),
                   format(max(forecast_dates), "%B %d, %Y"))

plot_ae <-
  plot_canonical(results, 
                 x = "ahead", 
                 y = "ae", 
                 aggr = mean) +
  labs(title = subtitle, x= "Weeks Ahead", y = "Mean AE",color='Forecasters') +  
  geom_point(aes(text=sprintf("Weeks Ahead: %s<br>Average Error: %s <br>Forecaster: %s", 
                              ahead, 
                              round(ae, digits=2),
                              color)),
             alpha = 0.05) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_y_log10()

if (params$colorblind_palette) {
  plot_ae <- plot_ae + 
    scale_color_viridis_d()
}

ggplotly(plot_ae, tooltip="text", width=1000) %>% 
  layout(hoverlabel = list(bgcolor = "white"))

plot_wis <-
  plot_canonical(results, 
                 x = "forecast_date", 
                 y = "wis", 
                 aggr = mean,
                 grp_vars = c("forecaster","ahead"), 
                 facet_rows = "ahead") + 
  labs(title = subtitle, 
       x = "Forecast Dates", 
       y = "Mean WIS",
       color = "Forecasters") +
  geom_point(aes(text=sprintf("Forecast Date: %s<br>Mean WIS: %s <br>Forecaster: %s", 
                              forecast_date, 
                              round(wis, digits = 2),
                              color)),
             alpha = 0.05) +
  facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead=weeks.label)) +
  theme(strip.background = element_rect(fill = "white")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = "center")) + 
  scale_y_log10()

if (params$colorblind_palette) {
  plot_wis <- plot_wis + 
    scale_color_viridis_d()
}

ggplotly(plot_wis, tooltip="text", height=800, width= 1000) %>% 
  layout(hoverlabel = list(bgcolor = "white"))

plot_cover <-
  plot_canonical(results, 
                 x = "forecast_date", 
                 y = "value_80", 
                 aggr = mean,
                 grp_vars = c("forecaster","ahead"), 
                 facet_rows = "ahead") +
  labs(title = subtitle, x= "Forecast date", y = "Mean Coverage 80", color='Forecasters') +
  geom_point(aes(text = sprintf("Forecast Date: %s<br>Coverage: %s <br>Forecaster: %s", 
                                forecast_date, 
                                round(value_80, digits = 2),
                                color)),
             alpha = 0.05) +
  facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = weeks.label)) +
  theme(strip.background = element_rect(fill = "white")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = "center")) +
  geom_line(mapping = aes(y = .8))

if (params$colorblind_palette) {
  plot_cover <- plot_cover + 
    scale_color_viridis_d()
}

ggplotly(plot_cover, tooltip="text", height=800, width=1000) %>% 
  layout(hoverlabel = list(bgcolor = "white"))
```


## (Geometric) Mean relative WIS 

Relative to baseline; scale first then take the geometric mean, ignoring a few 
0's. I think this is potentially more useful than the median/mean for relative 
WIS (or relative AE), but I haven't completely thought it through. 
Putting the results here to be provocative.

```{r, message = FALSE, warning = FALSE}
geom_mean <- function(x) prod(x)^(1/length(x))
#geom_mean <- exp(mean(log((x+1)/(y+1)))) #still need to figure this out

mean_wis <- 
  plot_canonical(results %>% 
                   filter(wis > 0), 
                 x = "ahead", 
                 y = "wis", 
                 aggr = geom_mean,
                 base_forecaster = "COVIDhub-baseline", 
                 scale_before_aggr = TRUE) + 
  labs(title = subtitle, 
       x = "Weeks Ahead", 
       y = "Mean (geometric) relative WIS", 
       color = "Forecasters") +
  geom_point(aes(text = sprintf("Weeks Ahead: %s<br>WIS: %s <br>Forecaster: %s", 
                                ahead, 
                                round(wis, digits = 2),
                                color)),
             alpha = 0.05) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = "center")) +
  geom_line(mapping = aes(y = 1))

if (params$colorblind_palette) {
  mean_wis <- mean_wis + 
    scale_color_viridis_d()
}

ggplotly(mean_wis, tooltip="text", width= 1000) %>% 
  layout(hoverlabel = list(bgcolor = "white"))

mean_wis_forecast_date <- 
plot_canonical(results %>% 
                 filter(wis > 0), 
               x = "forecast_date", 
               y = "wis", 
               aggr = geom_mean, 
               facet_rows = "ahead",
               grp_vars = c("forecaster", "ahead"),
               base_forecaster = "COVIDhub-baseline", 
               scale_before_aggr = TRUE) +
  theme(legend.position = "bottom") + 
  labs(title = subtitle, 
       x = "Forecast date", 
       y = "Mean (geometric) relative WIS", 
       color = "Forecasters") +
  geom_point(aes(text = sprintf("Forecast Date: %s<br>WIS: %s <br>Forecaster: %s", 
                                forecast_date, 
                                round(wis, digits = 2),
                                color)),
             alpha = 0.05) +
  facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = weeks.label)) +
  theme(strip.background = element_rect(fill = "white")) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = "center")) +
  geom_line(mapping = aes(y = 1))

if (params$colorblind_palette) {
  mean_wis_forecast_date <- mean_wis_forecast_date + 
    scale_color_viridis_d()
}

ggplotly(mean_wis_forecast_date, tooltip = "text", height=800, width= 1000) %>% 
  layout(hoverlabel = list(bgcolor = "white"))
```

## Scores by target date (not forecast date)

```{r, message = FALSE, warning = FALSE, include = FALSE}
# target_wis <-
#   plot_canonical(results, x = "target_end_date", y = "wis", aggr = mean,
#                dots = TRUE, grp_vars = "forecaster") + 
#   labs(title = subtitle, x = "Target date", y = "Mean WIS", color='Forecasters') +
#   scale_y_log10() +
#   geom_point(aes(text=sprintf("Target End Date: %s<br>WIS: %s <br>Forecaster: %s", target_end_date, round(wis, digits=2),color)),alpha = 0.05) +
#   theme_minimal() +
#   theme(plot.title = element_text(hjust = 'center'))
# 
# target_wis_ahead <-
#   plot_canonical(results, x = "target_end_date", y = "wis", aggr = mean,
#                dots = TRUE, grp_vars = c("forecaster", "ahead"), 
#                facet_rows = "ahead") +
#   labs(title = subtitle, x = "Target date", y = "Mean WIS", color='Forecasters') +
#   scale_y_log10() +
#   geom_point(aes(text=sprintf("Target End Date: %s<br>WIS: %s <br>Forecaster: %s", target_end_date, round(wis, digits=2),color)),alpha = 0.05)+
#   facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead=weeks.label))+
#   theme(strip.background = element_rect(fill = "white")) +
#   theme_minimal() +
#   theme(plot.title = element_text(hjust = 'center'))
# 
# ggplotly(target_wis, tooltip="text", width= 1000) %>% layout(hoverlabel=list(bgcolor='white'))
# ggplotly(target_wis_ahead, tooltip="text", height=800, width= 1000) %>% layout(hoverlabel=list(bgcolor='white'))
```

## Maps (mean score over forecast dates and aheads)

Note that the results are scaled by population.

```{r maps-processing, warning=FALSE}
library(sf)
maps <- results %>%
  group_by(geo_value, forecaster) %>%
  summarise(across(wis:ae, mean)) %>%
  left_join(animalia::state_population, by = "geo_value") %>%
  mutate(across(wis:ae, ~ .x / population * 1e5)) %>%
  pivot_longer(wis:ae, names_to = "score") %>%
  group_by(score) %>%
  mutate(time_value = Sys.Date(),
         r = max(value)) %>%
  group_by(forecaster, .add = TRUE) %>%
  group_split()
# for county prediction, set geo_type = "county"
maps <- purrr::map(maps, 
                   ~as.covidcast_signal(
                     .x, signal = .x$score[1], 
                     data_source = .x$forecaster[1], 
                     geo_type = "state"))

maps <- purrr::map(maps,
                   ~plot(.x, 
                         choro_col = scales::viridis_pal()(3),
                         range = c(0,.x$r[1])))

nfcasts <- length(unique(results$forecaster))
```

### Mean AE

```{r map-ae, fig.width=12, fig.height=8}
# original code
cowplot::plot_grid(plotlist = maps[1:nfcasts], ncol = 3)
```

### Mean WIS

```{r map-wis, fig.width=12, fig.height=8}
cowplot::plot_grid(plotlist = maps[(nfcasts+1):length(maps)], ncol = 3)
```

## Trajectory plots

<!-- For county predictions, you might want to change the `fig.height` and `fig.width` chunk options here (in other notebooks we use `fig.height = 120` and `fig.width = 30`). -->

<!-- ```{r} -->
<!-- # for county prediction, set geo_type = "county" -->
<!-- state.label = c(state.name, "Washington D.C.", "Porto Rico") -->
<!-- names(state.label) = c(tolower(state.abb), "dc", "pr") -->

<!-- pd <- evalcast:::setup_plot_trajectory( -->
<!--   bind_rows(state_predictions, submitted %>% -->
<!--               filter(forecaster == "CMU-TimeSeries")), -->
<!--   intervals = 0.8, -->
<!--   geo_type = "state", -->
<!--   start_day = min(forecast_dates) - 60) -->

<!-- g <- ggplot(pd$truth_df, mapping = aes(x = target_end_date)) -->
<!-- # build the fan -->
<!-- g <- g + geom_ribbon( -->
<!--   data = pd$quantiles_df %>% -->
<!--     mutate(upper = round(upper, 2), -->
<!--            lower = round(lower, 2)), -->
<!--   mapping = aes(ymin = lower, -->
<!--                 ymax = upper, -->
<!--                 fill = forecaster, -->
<!--                 group = interaction(forecaster, forecast_date)), -->
<!--   alpha = .1) + -->
<!--   scale_fill_viridis_d(begin=.15, end=.85) -->

<!-- # line layer -->
<!-- g <- g + -->
<!--   #geom_line(aes(y = .data$value.y), color = "#3182BD") + # corrected -->
<!--   geom_line(aes(y = value), size = .5) + # reported -->
<!--   geom_line(data = pd$points_df, -->
<!--             mapping = aes(y = value, -->
<!--                           color = forecaster, -->
<!--                           group = interaction(forecaster, forecast_date)), -->
<!--             size = .5) + -->
<!--   geom_point(aes(y = value), size = 1) + # reported gets dots -->
<!--   geom_point(data = pd$points_df %>% -->
<!--                mutate(value = round(value, 2)), -->
<!--              mapping = aes(y = value, color = forecaster), -->
<!--              size = 1) + -->
<!--   scale_color_viridis_d(begin=.15, end=.85) -->
<!-- ``` -->

<!-- ```{r state trajectories, fig.height = 60, fig.width = 20, dev="CairoSVG"} -->
<!-- states <- g  + -->
<!--   facet_wrap(~geo_value, -->
<!--              scales = "free_y", -->
<!--              ncol = 3, -->
<!--              labeller = labeller(geo_value = state.label)) + -->
<!--   labs(x = "", y = "") + -->
<!--   theme_bw() + -->
<!--   theme(legend.position = "none", strip.background = element_rect(fill = "white")) -->

<!-- ggplotly(states, height=5000, width= 1000) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- options(timeout=200) -->
<!-- url2 <- "https://forecast-eval.s3.us-east-2.amazonaws.com/predictions_cards.rds" -->
<!-- download.file(url2, "test.RDS") # download to disk -->
<!-- state_predictions <- readRDS(paste0(here(), "/test.RDS")) -->
<!-- ``` -->
